# 类初始化和实例初始化
![图片无法加载](https://github.com/Ywfy/Summary-of-interview-questions/blob/master/Initialization/Initialize.png)<br>

## 要点
### 类初始化
* 一个类要创建实例需要先加载并初始化该类
  * main方法所在的类要先加载和初始化
* 一个子类要初始化需要先初始化父类
* 一个类初始化就是执行<clinit>()方法
  * <clinit>()方法由静态类变量显式赋值代码和静态代码块组成
  * 类变量显式赋值代码和静态代码块代码从上到下顺序执行
  * <clinit>()方法只执行一次
  
题目分析
* 显然，因为main函数在Son类下，故要加载和初始化Son类
* 但因为Son类是Father的子类，故要先加载并初始化Father类
* Father的初始化<clinit>:
   * private static int j = method();
   * Father的静态代码块
* 接下来进行Son类的初始化<clinit>:
   * private static int j = method();
   * Son类的静态代码块

故此时会显示(5)(1)(10)(6)

### 实例初始化
* 实例初始化就是执行<init>()方法
  * <init>()方法可能重载有多个，有几个构造器就有几个<init>方法
  * <init>()方法由非静态实例变量显式赋值代码和非静态代码块、对应构造器代码组成
  * 非静态实例变量显式赋值代码和非静态代码块代码从上到下顺序执行，而对应构造器的代码最后执行
  * 每次创建实例对象，调用对应构造器，执行的就是对应的<init>方法
  * <init>方法的首行是super()或super(实参列表),即对应父类的<init>方法,也就是先执行父类的实例初始化

题目分析
* 要实例化Son，因为Son是Father的子类，故先实例初始化Father
* Father的实例化
  * private int i = test(); 此处会涉及到方法的重写
    * 非静态方法前面其实有一个默认的对象this
    * this在构造器(或<init>)它表示的是正在创建的对象,而此处正在创建的对象是Son
    * 注意，至始至终创建的只有一个对象，它的具体类型是Son
    * 所以此处会运用到Java的多态性，去执行Son的test()方法
  * Father的非静态代码块
  * Father的构造器
* Son的实例化
  * private int i = test();
  * Son的非静态代码块
  * Son的构造器
  
所以结果为(9)(3)(2)(9)(8)(7)

<br>
接下来就很简单了，换行，然后再一次实例化,(9)(3)(2)(9)(8)(7)
<br><br>

所以最终的结果为
```
(5)(1)(10)(6)(9)(3)(2)(9)(8)(7)
(9)(3)(2)(9)(8)(7)
```

### 补充：方法重写Override
* 哪些方法不可以被重写
  * final方法
  * static静态方法
  * private等子类中不可见方法
* 对象的多态性
  * 子类如果重写了父类的方法，通过子类对象调用的一定是子类重写过的代码
  * 非静态方法默认的调用对象是this
  * this对象在构造器或者说<init>方法中就是正在创建的对象
* Override重写的要求？
  * 修饰符 子类中方法的访问修饰符必须 >= 父类中对应方法的访问修饰符 （public > protected > default）
  * 返回值类型 子类中方法的返回值类型可以和被重写方法的返回值类型相同，或者是被重写方法类型的子类型。
  * 方法名
  * 形参列表
  * 抛出的异常列表
  
总的说就是作为一个方法所能拥有的所有元素都要一样
<br><br>

面试题：重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？ 
```
答：方法的重载和重写都是实现多态的方法，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类
中，同名的方法如果有不同的参数列表(参数类型不同、参数个数不同或者二者都不同)则视为重载；重写发生在子类与父类之间，重写要求
子类重写方法比父类被重写方法修饰符访问范围大，返回值类型相同或者是父类方法返回值类型的子类，方法名、参数列表要完全相同，抛
出的异常列表也要一致。
```
